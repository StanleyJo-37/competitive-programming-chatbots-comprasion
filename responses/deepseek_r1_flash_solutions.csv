solutions,completion_tokens,prompt_tokens,timestampKF,question,difficulty,raw_tags,tags,skill_types,Expected Auxiliary Space,time_limit,memory_limit,Expected Time Complexity,prompts,inputs,outputs,response,output_tokens,generation_time
,,0,,"Volodya likes listening to heavy metal and (occasionally) reading. No wonder Volodya is especially interested in texts concerning his favourite music style.

Volodya calls a string powerful if it starts with ""heavy"" and ends with ""metal"". Finding all powerful substrings (by substring Volodya means a subsequence of consecutive characters in a string) in a given text makes our hero especially joyful. Recently he felt an enormous fit of energy while reading a certain text. So Volodya decided to count all powerful substrings in this text and brag about it all day long. Help him in this difficult task. Two substrings are considered different if they appear at the different positions in the text.

For simplicity, let us assume that Volodya's text can be represented as a single string.


-----Input-----

Input contains a single non-empty string consisting of the lowercase Latin alphabet letters. Length of this string will not be greater than 10^6 characters.


-----Output-----

Print exactly one number — the number of powerful substrings of the given string.

Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.


-----Examples-----
Input
heavymetalisheavymetal

Output
3
Input
heavymetalismetal

Output
2
Input
trueheavymetalissotruewellitisalsosoheavythatyoucanalmostfeeltheweightofmetalonyou

Output
3


-----Note-----

In the first sample the string ""heavymetalisheavymetal"" contains powerful substring ""heavymetal"" twice, also the whole string ""heavymetalisheavymetal"" is certainly powerful.

In the second sample the string ""heavymetalismetal"" contains two powerful substrings: ""heavymetal"" and ""heavymetalismetal"".",EASY,"['two pointers', 'strings', 'implementation']","['String algorithms', 'Amortized analysis', 'Implementation']",['Amortized analysis'],,,,,"Below is provided a **competitive programming** problem set.
Please solve the problem set with:
1. No pre-assumptions (every assumption has to be structured in comments, whether it is inline or in a block).
2. **Solve using C++.**3. Keeping in mind that the solution can actually reproduce the correct inputs and outputs as will be provided.
4. Only provide solution as the answer without any alternatives **(pick the best of all possibilities with best practices and performance)**.5. **All explanation MUST be inside of the code itself in the forms of comments.**
**Question**
Volodya likes listening to heavy metal and (occasionally) reading. No wonder Volodya is especially interested in texts concerning his favourite music style.

Volodya calls a string powerful if it starts with ""heavy"" and ends with ""metal"". Finding all powerful substrings (by substring Volodya means a subsequence of consecutive characters in a string) in a given text makes our hero especially joyful. Recently he felt an enormous fit of energy while reading a certain text. So Volodya decided to count all powerful substrings in this text and brag about it all day long. Help him in this difficult task. Two substrings are considered different if they appear at the different positions in the text.

For simplicity, let us assume that Volodya's text can be represented as a single string.


-----Input-----

Input contains a single non-empty string consisting of the lowercase Latin alphabet letters. Length of this string will not be greater than 10^6 characters.


-----Output-----

Print exactly one number — the number of powerful substrings of the given string.

Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.


-----Examples-----
Input
heavymetalisheavymetal

Output
3
Input
heavymetalismetal

Output
2
Input
trueheavymetalissotruewellitisalsosoheavythatyoucanalmostfeeltheweightofmetalonyou

Output
3


-----Note-----

In the first sample the string ""heavymetalisheavymetal"" contains powerful substring ""heavymetal"" twice, also the whole string ""heavymetalisheavymetal"" is certainly powerful.

In the second sample the string ""heavymetalismetal"" contains two powerful substrings: ""heavymetal"" and ""heavymetalismetal"".

**Difficulty: EASY**

**Raw Tags: ['two pointers', 'strings', 'implementation']**

**Tags: ['String algorithms', 'Amortized analysis', 'Implementation']**

**Skill Types: ['Amortized analysis']**

**Expected Auxiliary Space: No expected aurxiliary space or auxiliary space limit.**

**Time Limit: No time limit.**

**Memory Limit: No memory limit**

**Expected Time Complexity: No expected time complexity or time complexity limit.**
","['heavymetalisheavymetal\n', 'heavymetalismetal\n', 'trueheavymetalissotruewellitisalsosoheavythatyoucanalmostfeeltheweightofmetalonyou\n', 'fpgzbvhheavymheheavyzmheavyavyebknkhheavyhsbqmmetheavyalmetalheavyyomtua\n', 'metametaheavyetalalmetalavylkeoheavyhemetaleavycdk\n', 'hg\n', 'fpgzbvhheavymheheavyzmheavyavyebknkhheavyhsbqmmetheavyalmetalheavyyomtua\n', 'hg\n', 'metametaheavyetalalmetalavylkeoheavyhemetaleavycdk\n', 'fpgzbvhheavymheheavyzmheavyavyebknkhheavyhsbqmmetheavyalmetblheavyyomtua\n', 'metametaheavyetalalmetalavymkeoheavyheletaleavycdk\n', 'trueheavymetalissotruewellitisalsosoheavythatyoucanalmosteeeltheweightofmetalonyou\n', 'hh\n', 'heavymetalisheavymdtal\n', 'heavymetblismetal\n', 'fpgzbvhheavymheheavyzmheavyavyebknkhheavyhsbqmmetheavyolmetblheavyyamtua\n', 'gh\n', 'kdcyvaelatelehyvaehoekmyvalatemlalateyvaehatematem\n', 'heavymetalasheavymdtil\n', 'trueheavymetalissotrufwellitisalsosoheavythatyoucanalmosteeeltheweightofmetalonyou\n', 'latemsilbtemyvaeh\n', 'fpgzbvhheavymheheavyzmheavyavyebknkhheavyhsbqmmetheavyolmftblheavyyamtua\n', 'gi\n', 'kdcyvaelatelehyvaehoekmywalatemlalateyvaehatematem\n', 'heavymltaeasheavymdtil\n', 'uoynolatemfothgiewehtleeetsomlanacuoytahtyvaehososlasitillewfurtossilatemyvaeheurt\n', 'latemlisbtemyvaeh\n', 'fpgzbvhheavymheheavyzmheavyavyebknkhheavyhsbqmmftheavyolmftblheavyyamtua\n', 'fi\n', 'kdcyvaekatelehyvaehoekmywalatemlalateyvaehatematem\n', 'heavymltaeasehavymdtil\n', 'uoynolatemfothgiewehtleeetsomlanacuoytahtyvaehosorlasitillewfurtossilatemyvaeheurt\n', 'latemlisbtemvyaeh\n', 'fpgzbvhheavymheheavyzmheavyavyebknkhheavyhsbqmmftheavyplmftblheavyyamtua\n', 'gj\n', 'kdcyaaekatelehyvaehoekmywvlatemlalateyvaehatematem\n', 'litdmyvahesaeatlmyvaeh\n', 'uoynolatemfothgiewehtleeetsomlanacuoytahtyvaehosorlasitillewfurtossilatelyvaeheurt\n', 'latemlisbtfmvyaeh\n', 'fpgzbvhheavymheheauyzmheavyavyebknkhheavyhsbqmmftheavyplmftblheavyyamtua\n', 'fj\n', 'kdcyaaekatelehyvaehoekmywwlatemlalateyvaehatematem\n', 'liudmyvahesaeatlmyvaeh\n', 'uoynolatemfothgiewehtleeetsomlanacuoytahtyvaehosorlasitillewfurtossilatelyv`eheurt\n', 'latemlisbtfmvayeh\n', 'fpgzbvhheavymheheauyzmheavyavyebknkhheavyhsbqmmftheavypllftblheavyyamtua\n', 'jf\n', 'kdcyaaekatelehyvaehoekmywwlatemlalatayvaehatemetem\n', 'heavymltaeasehavymduil\n', 'uoynolatemfothgiewehtleeetsomlanacuoytahtyvaehosorlasitillewgurtossilatelyv`eheurt\n', 'latemlimbtfsvayeh\n', 'fpgzbvhheavymheheauyzmheavyavyebknkheeavyhsbqmmftheavypllftblhhavyyamtua\n', 'je\n', 'kdcyaaekatelehyvaehoekmywwlatemlakatayvaehatemetem\n', 'heavyaltaeasehmvymduil\n', 'uoynolatemfothgiewehtleeetsomlanacuoytahtyvaehosorlasitillewgurtossilattlyv`eheure\n', 'latemlimstfbvayeh\n', 'fpgzbvhheavymheheauyzhheavyavyebknkmeeavyhsbqmmftheavypllftblhhavyyamtua\n', 'ej\n', 'kdcyaaekatelewyvaehoekmyhwlatemlakatayvaehatemetem\n', 'heavyaltaeahesmvymduil\n', 'uoynolasemfothgiewehtleeetsomlanacuoytahtyvaehosorlasitillewgurtossilattlyv`eheure\n', 'heyavbftsmilmetal\n', 'fpgzbvhheavymheheauyzhheavyavyebknkmeeavyhsbqmmftheavypllftblhhavyy`mtua\n', 'ei\n', 'kddyaaekatelewyvaehoekmyhwlatemlakatayvaehatemetem\n', 'liudmyvmsehaeatlayvaeh\n', 'uoynolasemfothgiewehtleeetsomlanacuoytahtyvaehosorlasitimlewgurtossilattlyv`eheure\n', 'heyavbftsmhlmetal\n', 'fpgzbvhheavymheheauyzhheavyavyebknkmeeavyhsbqmmftieavypllftblhhavyy`mtua\n', 'ie\n', 'kddyaaekatelewyvaehoelmyhwlatemlakatayvaehatemetem\n', 'liudmyvmsehaeatlazvaeh\n', 'uoylolasemfothgiewehtleeetsomlanacuoytahtyvaehosorlasitimnewgurtossilattlyv`eheure\n', 'hdyavbftsmhlmetal\n', 'fpgzbvhheavymheheauyzhheavyavyebknkmeeavyhsbqmmftieavypllftblhhavyx`mtua\n', 'he\n', 'metemetaheavyatakalmetalwhymleoheavyweletakeaayddk\n', 'liudmywmsehaeatlazvaeh\n', 'uoylolasemfothgiewehtleeetsomlanacuoytahtyvaehosoqlasitimnewgurtossilattlyv`eheure\n', 'latemlhmstfbvaydh\n', 'fpgzbvhheavymheheauyzhheavyavyebknkmeeavyhsbqmmftheavypllftblhhavyx`mtua\n', 'eh\n', 'kddyaaekatelewyv`ehoelmyhwlatemlakatayvaehatemetem\n', 'ltudmywmsehaeailazvaeh\n', 'eruehe`vylttalissotrugwenmitisalqosoheavythatyoucanalmosteeeltheweightofmesalolyou\n', 'hdyavbfttmhlmetal\n', 'fpgzyvhheavymheheauyzhheavyavyebknkmeeavyhsbqmmftheavbpllftblhhavyx`mtua\n', 'ek\n', 'kddyaaekatelewyv`ehoelmyhwlatemlakatayvaehatemesem\n', 'ktudmywmsehaeailazvaeh\n', 'eruehe`vylttalissotrugwenmitisalqosoheavythatyoucanalmosteeeltheweighuofmesalolyou\n', 'latemlhmttfbvaydh\n', 'fpgzyvhheavymheheauyzhheavyavyebknkmeeavyhsbqmmftheavbpllfttlhhavyx`mbua\n', 'dk\n', 'kddyaaekttelewyv`ehoelmyhwlatemlakaaayvaehatemesem\n', 'ktudmywmsehaeavlaziaeh\n', 'eruehe`vylttalissotrugwenmitisalqosoheavyuhatyoucanalmosteeeltheweightofmesalolyou\n', 'hdyavbfttmhlmeual\n', 'fpgzyvhhebvymheheauyzhheavyavyebknkmeeavyhsbqmmftheavbpllfttlhhavyx`mbua\n', 'kd\n', 'kddyaaekstelewyv`ehoelmyhwlatemlakaaayvaehatemesem\n', 'ktydmuwmsehaeavlaziaeh\n', 'uoylolasemfothgiewehtleeetsomlanacuoytahuyvaehosoqlasitimnewgurtossilattlyv`eheure\n', 'lauemlhmttfbvaydh\n', 'fpgzyvhhebvymheheauyzhheavyavyebknkmee`vyhsbqmmftheavbpllfttlhhavyx`mbua\n', 'ke\n', 'kddyaadkstelewyv`ehoelmyhwlatemlakaaayvaehatemesem\n', 'ktydmuwsmehaeavlaziaeh\n', 'heavymetalisheavymetal\n', 'trueheavymetalissotruewellitisalsosoheavythatyoucanalmostfeeltheweightofmetalonyou\n', 'heavymetalismetal\n']","['3', '2', '3', '5', '3', '0', '5\n', '0\n', '3\n', '0\n', '1\n', '3\n', '0\n', '1\n', '1\n', '0\n', '0\n', '0\n', '1\n', '3\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '1\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '0\n', '3\n', '3\n', '2\n']",,0.0,0.3786768913269043
,,0,,"A couple of friends, Axel and Marston are travelling across the country of Bitland. There are n towns in Bitland, with some pairs of towns connected by one-directional roads. Each road in Bitland is either a pedestrian road or a bike road. There can be multiple roads between any pair of towns, and may even be a road from a town to itself. However, no pair of roads shares the starting and the destination towns along with their types simultaneously.

The friends are now located in the town 1 and are planning the travel route. Axel enjoys walking, while Marston prefers biking. In order to choose a route diverse and equally interesting for both friends, they have agreed upon the following procedure for choosing the road types during the travel:

  * The route starts with a pedestrian route.
  * Suppose that a beginning of the route is written in a string s of letters P (pedestrain road) and B (biking road). Then, the string <image> is appended to s, where <image> stands for the string s with each character changed to opposite (that is, all pedestrian roads changed to bike roads, and vice versa).



In the first few steps the route will look as follows: P, PB, PBBP, PBBPBPPB, PBBPBPPBBPPBPBBP, and so on.

After that the friends start travelling from the town 1 via Bitlandian roads, choosing the next road according to the next character of their route type each time. If it is impossible to choose the next road, the friends terminate their travel and fly home instead.

Help the friends to find the longest possible route that can be travelled along roads of Bitland according to the road types choosing procedure described above. If there is such a route with more than 1018 roads in it, print -1 instead.

Input

The first line contains two integers n and m (1 ≤ n ≤ 500, 0 ≤ m ≤ 2n2) — the number of towns and roads in Bitland respectively.

Next m lines describe the roads. i-th of these lines contains three integers vi, ui and ti (1 ≤ vi, ui ≤ n, 0 ≤ ti ≤ 1), where vi and ui denote start and destination towns indices of the i-th road, and ti decribes the type of i-th road (0 for a pedestrian road, 1 for a bike road). It is guaranteed that for each pair of distinct indices i, j such that 1 ≤ i, j ≤ m, either vi ≠ vj, or ui ≠ uj, or ti ≠ tj holds.

Output

If it is possible to find a route with length strictly greater than 1018, print -1. Otherwise, print the maximum length of a suitable path.

Examples

Input

2 2
1 2 0
2 2 1


Output

3


Input

2 3
1 2 0
2 2 1
2 2 0


Output

-1

Note

In the first sample we can obtain a route of length 3 by travelling along the road 1 from town 1 to town 2, and then following the road 2 twice from town 2 to itself.

In the second sample we can obtain an arbitrarily long route by travelling the road 1 first, and then choosing road 2 or 3 depending on the necessary type.",VERY_HARD,"['bitmasks', 'graphs', 'matrices', 'dp']","['Matrices', 'Bit manipulation', 'Graph algorithms', 'Dynamic programming']","['Dynamic programming', 'Bit manipulation']",,5.0 seconds,256.0 megabytes,,"Below is provided a **competitive programming** problem set.
Please solve the problem set with:
1. No pre-assumptions (every assumption has to be structured in comments, whether it is inline or in a block).
2. **Solve using C++.**3. Keeping in mind that the solution can actually reproduce the correct inputs and outputs as will be provided.
4. Only provide solution as the answer without any alternatives **(pick the best of all possibilities with best practices and performance)**.5. **All explanation MUST be inside of the code itself in the forms of comments.**
**Question**
A couple of friends, Axel and Marston are travelling across the country of Bitland. There are n towns in Bitland, with some pairs of towns connected by one-directional roads. Each road in Bitland is either a pedestrian road or a bike road. There can be multiple roads between any pair of towns, and may even be a road from a town to itself. However, no pair of roads shares the starting and the destination towns along with their types simultaneously.

The friends are now located in the town 1 and are planning the travel route. Axel enjoys walking, while Marston prefers biking. In order to choose a route diverse and equally interesting for both friends, they have agreed upon the following procedure for choosing the road types during the travel:

  * The route starts with a pedestrian route.
  * Suppose that a beginning of the route is written in a string s of letters P (pedestrain road) and B (biking road). Then, the string <image> is appended to s, where <image> stands for the string s with each character changed to opposite (that is, all pedestrian roads changed to bike roads, and vice versa).



In the first few steps the route will look as follows: P, PB, PBBP, PBBPBPPB, PBBPBPPBBPPBPBBP, and so on.

After that the friends start travelling from the town 1 via Bitlandian roads, choosing the next road according to the next character of their route type each time. If it is impossible to choose the next road, the friends terminate their travel and fly home instead.

Help the friends to find the longest possible route that can be travelled along roads of Bitland according to the road types choosing procedure described above. If there is such a route with more than 1018 roads in it, print -1 instead.

Input

The first line contains two integers n and m (1 ≤ n ≤ 500, 0 ≤ m ≤ 2n2) — the number of towns and roads in Bitland respectively.

Next m lines describe the roads. i-th of these lines contains three integers vi, ui and ti (1 ≤ vi, ui ≤ n, 0 ≤ ti ≤ 1), where vi and ui denote start and destination towns indices of the i-th road, and ti decribes the type of i-th road (0 for a pedestrian road, 1 for a bike road). It is guaranteed that for each pair of distinct indices i, j such that 1 ≤ i, j ≤ m, either vi ≠ vj, or ui ≠ uj, or ti ≠ tj holds.

Output

If it is possible to find a route with length strictly greater than 1018, print -1. Otherwise, print the maximum length of a suitable path.

Examples

Input

2 2
1 2 0
2 2 1


Output

3


Input

2 3
1 2 0
2 2 1
2 2 0


Output

-1

Note

In the first sample we can obtain a route of length 3 by travelling along the road 1 from town 1 to town 2, and then following the road 2 twice from town 2 to itself.

In the second sample we can obtain an arbitrarily long route by travelling the road 1 first, and then choosing road 2 or 3 depending on the necessary type.

**Difficulty: VERY_HARD**

**Raw Tags: ['bitmasks', 'graphs', 'matrices', 'dp']**

**Tags: ['Matrices', 'Bit manipulation', 'Graph algorithms', 'Dynamic programming']**

**Skill Types: ['Dynamic programming', 'Bit manipulation']**

**Expected Auxiliary Space: No expected aurxiliary space or auxiliary space limit.**

**Time Limit: 5.0 seconds**

**Memory Limit: 256.0 megabytes**

**Expected Time Complexity: No expected time complexity or time complexity limit.**
","['1 2\n1 1 0\n1 1 1\n', '3 13\n1 3 1\n1 1 0\n1 1 1\n2 3 1\n2 2 0\n3 2 1\n3 1 0\n1 2 1\n2 1 0\n1 3 0\n2 3 0\n2 2 1\n3 3 0\n', '5 0\n', '1 1\n1 1 0\n', '3 6\n3 1 1\n1 2 1\n2 1 1\n1 3 0\n3 2 1\n2 2 0\n', '2 2\n2 1 1\n1 2 0\n', '3 0\n', '4 2\n2 1 1\n1 2 0\n', '2 3\n1 2 0\n2 2 1\n2 2 1\n', '1 2\n1 1 0\n1 1 0\n', '5 6\n3 1 1\n1 2 1\n2 1 1\n1 3 0\n3 2 1\n2 2 0\n', '5 6\n3 2 1\n1 2 1\n2 1 1\n1 3 0\n3 2 1\n2 2 0\n', '3 13\n1 3 1\n1 1 0\n1 1 1\n2 3 1\n2 2 0\n3 2 1\n3 1 0\n1 2 1\n2 1 0\n2 3 0\n2 3 0\n2 2 1\n3 3 0\n', '1 0\n1 1 0\n', '1 0\n2 1 0\n', '1 0\n2 2 0\n', '0 0\n2 2 0\n', '0 0\n2 3 0\n', '0 0\n0 3 0\n', '0 0\n', '2 1\n2 1 1\n1 2 0\n', '1 0\n', '1 0\n1 2 0\n', '1 1\n2 1 0\n', '1 0\n2 2 -1\n', '0 0\n1 2 0\n', '0 0\n2 5 0\n', '0 0\n0 0 0\n', '1 2\n1 2 0\n1 1 0\n', '2 1\n2 1 1\n1 2 1\n', '1 0\n1 4 0\n', '1 1\n4 1 0\n', '1 0\n0 2 -1\n', '0 0\n2 0 0\n', '0 0\n-1 0 0\n', '5 6\n3 3 1\n1 2 1\n2 1 1\n1 3 0\n3 2 1\n2 2 0\n', '2 0\n2 1 1\n1 2 1\n', '1 0\n1 5 0\n', '1 1\n4 1 1\n', '2 0\n0 2 -1\n', '0 0\n2 1 0\n', '3 1\n2 1 1\n1 2 1\n', '1 0\n1 8 0\n', '1 1\n4 2 1\n', '2 0\n0 2 0\n', '0 0\n1 1 0\n', '3 1\n3 1 1\n1 2 1\n', '2 0\n0 2 1\n', '3 1\n3 1 1\n0 2 1\n', '3 1\n3 1 1\n0 2 2\n', '3 1\n3 1 1\n0 1 2\n', '3 1\n1 1 1\n0 1 2\n', '3 1\n1 1 1\n1 1 2\n', '3 1\n1 1 1\n1 2 2\n', '10 0\n', '3 6\n3 1 1\n1 2 1\n2 1 1\n1 2 0\n3 2 1\n2 2 0\n', '2 2\n1 2 0\n2 2 1\n', '2 3\n1 2 0\n2 2 1\n2 2 0\n']","['-1\n', '-1\n', '0', '1', '30', '2', '0', '2', '3', '1', '30', '24', '-1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1', '0', '0', '0', '0', '0', '0', '30', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '-1', '3', '-1\n']",,0.0,0.0
