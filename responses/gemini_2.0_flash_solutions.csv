question,difficulty,raw_tags,tags,skill_types,Expected Auxiliary Space,time_limit,memory_limit,Expected Time Complexity,prompts,inputs,outputs,response
"$ \def\myred#1{{\underline{\bf{#1}}}} \def\myblue#1{\color{blue}{\overline{\bf{#1}}}} $ $\def\RED{\myred{Red}} \def\BLUE{\myblue{Blue}}$

You are given a sequence of $n$ non-negative integers $a_1, a_2, \ldots, a_n$. Initially, all the elements of the sequence are unpainted. You can paint each number $\RED$ or $\BLUE$ (but not both), or leave it unpainted.

For a color $c$, $\text{Count}(c)$ is the number of elements in the sequence painted with that color and $\text{Sum}(c)$ is the sum of the elements in the sequence painted with that color.

For example, if the given sequence is $[2, 8, 6, 3, 1]$ and it is painted this way: $[\myblue{2}, 8, \myred{6}, \myblue{3}, 1]$ (where $6$ is painted red, $2$ and $3$ are painted blue, $1$ and $8$ are unpainted) then $\text{Sum}(\RED)=6$, $\text{Sum}(\BLUE)=2+3=5$, $\text{Count}(\RED)=1$, and $\text{Count}(\BLUE)=2$.

Determine if it is possible to paint the sequence so that $\text{Sum}(\RED) > \text{Sum}(\BLUE)$ and $\text{Count}(\RED) < \text{Count}(\BLUE)$.


-----Input-----

Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \le t \le 1000$). Description of the test cases follows.

The first line of each test case contains an integer $n$ ($3\le n\le 2\cdot 10^5$) — the length of the given sequence.

The second line of each test case contains $n$ integers $a_1,a_2,\ldots,a_n$ ($0\le a_i\le 10^9$) — the given sequence.

It is guaranteed that the sum of $n$ over all test cases does not exceed $2\cdot 10^5$.


-----Output-----

For each test case, print YES if it is possible to paint the given sequence satisfying the above requirements, and NO otherwise.

You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).


-----Examples-----

Input
4
3
1 2 3
5
2 8 6 3 1
4
3 5 4 2
5
1000000000 1000000000 1000000000 1000000000 1000000000
Output
NO
YES
NO
NO


-----Note-----

In the first test case, there is no possible way to paint the sequence. For example, if you paint the sequence this way: $[\myblue{1},\myblue{2},\myred{3}]$ (where $3$ is painted red, $1$ and $2$ are painted blue) then $\text{Count}(\RED)=1 < \text{Count}(\BLUE)=2$, but $\text{Sum}(\RED)=3 \ngtr \text{Sum}(\BLUE)=3$. So, this is not a possible way to paint the sequence.

In the second test case, a possible way to paint the sequence is described in the statement. We can see that $\text{Sum}(\RED)=6 > \text{Sum}(\BLUE)=5$ and $\text{Count}(\RED)=1 < \text{Count}(\BLUE)=2$.

In the third test case, there is no possible way to paint the sequence. For example, if you paint the sequence this way: $[\myred{3},\myred{5},\myblue{4}, \myblue{2}]$ (where $3$ and $5$ are painted red, $4$ and $2$ are painted blue) then $\text{Sum}(\RED) = 8 > \text{Sum}(\BLUE) = 6$ but $\text{Count}(\RED) = 2 \nless \text{Count}(\BLUE) = 2$. So, this is not a possible way to paint the sequence.

In the fourth test case, it can be proven that there is no possible way to paint the sequence satisfying sum and count constraints.",EASY,"['greedy', 'two pointers', 'brute force', 'sortings', 'constructive algorithms']","['Constructive algorithms', 'Sorting', 'Amortized analysis', 'Greedy algorithms', 'Complete search']","['Complete search', 'Sorting', 'Amortized analysis', 'Greedy algorithms']",,2 seconds,256 megabytes,,"Below is provided a **competitive programming** problem set.
Please solve the problem set with:
1. No pre-assumptions (every assumption has to be structured in comments, whether it is inline or in a block).
2. **Solve using C++.**3. Keeping in mind that the solution can actually reproduce the correct inputs and outputs as will be provided.
4. Only provide solution as the answer without any alternatives **(pick the best of all possibilities with best practices and performance)**.5. **All explanation MUST be inside of the code itself in the forms of comments.**
**Question**
$ \def\myred#1{{\underline{\bf{#1}}}} \def\myblue#1{\color{blue}{\overline{\bf{#1}}}} $ $\def\RED{\myred{Red}} \def\BLUE{\myblue{Blue}}$

You are given a sequence of $n$ non-negative integers $a_1, a_2, \ldots, a_n$. Initially, all the elements of the sequence are unpainted. You can paint each number $\RED$ or $\BLUE$ (but not both), or leave it unpainted.

For a color $c$, $\text{Count}(c)$ is the number of elements in the sequence painted with that color and $\text{Sum}(c)$ is the sum of the elements in the sequence painted with that color.

For example, if the given sequence is $[2, 8, 6, 3, 1]$ and it is painted this way: $[\myblue{2}, 8, \myred{6}, \myblue{3}, 1]$ (where $6$ is painted red, $2$ and $3$ are painted blue, $1$ and $8$ are unpainted) then $\text{Sum}(\RED)=6$, $\text{Sum}(\BLUE)=2+3=5$, $\text{Count}(\RED)=1$, and $\text{Count}(\BLUE)=2$.

Determine if it is possible to paint the sequence so that $\text{Sum}(\RED) > \text{Sum}(\BLUE)$ and $\text{Count}(\RED) < \text{Count}(\BLUE)$.


-----Input-----

Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \le t \le 1000$). Description of the test cases follows.

The first line of each test case contains an integer $n$ ($3\le n\le 2\cdot 10^5$) — the length of the given sequence.

The second line of each test case contains $n$ integers $a_1,a_2,\ldots,a_n$ ($0\le a_i\le 10^9$) — the given sequence.

It is guaranteed that the sum of $n$ over all test cases does not exceed $2\cdot 10^5$.


-----Output-----

For each test case, print YES if it is possible to paint the given sequence satisfying the above requirements, and NO otherwise.

You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).


-----Examples-----

Input
4
3
1 2 3
5
2 8 6 3 1
4
3 5 4 2
5
1000000000 1000000000 1000000000 1000000000 1000000000
Output
NO
YES
NO
NO


-----Note-----

In the first test case, there is no possible way to paint the sequence. For example, if you paint the sequence this way: $[\myblue{1},\myblue{2},\myred{3}]$ (where $3$ is painted red, $1$ and $2$ are painted blue) then $\text{Count}(\RED)=1 < \text{Count}(\BLUE)=2$, but $\text{Sum}(\RED)=3 \ngtr \text{Sum}(\BLUE)=3$. So, this is not a possible way to paint the sequence.

In the second test case, a possible way to paint the sequence is described in the statement. We can see that $\text{Sum}(\RED)=6 > \text{Sum}(\BLUE)=5$ and $\text{Count}(\RED)=1 < \text{Count}(\BLUE)=2$.

In the third test case, there is no possible way to paint the sequence. For example, if you paint the sequence this way: $[\myred{3},\myred{5},\myblue{4}, \myblue{2}]$ (where $3$ and $5$ are painted red, $4$ and $2$ are painted blue) then $\text{Sum}(\RED) = 8 > \text{Sum}(\BLUE) = 6$ but $\text{Count}(\RED) = 2 \nless \text{Count}(\BLUE) = 2$. So, this is not a possible way to paint the sequence.

In the fourth test case, it can be proven that there is no possible way to paint the sequence satisfying sum and count constraints.

**Difficulty: EASY**

**Raw Tags: ['greedy', 'two pointers', 'brute force', 'sortings', 'constructive algorithms']**

**Tags: ['Constructive algorithms', 'Sorting', 'Amortized analysis', 'Greedy algorithms', 'Complete search']**

**Skill Types: ['Complete search', 'Sorting', 'Amortized analysis', 'Greedy algorithms']**

**Expected Auxiliary Space: No expected aurxiliary space or auxiliary space limit.**

**Time Limit: 2 seconds**

**Memory Limit: 256 megabytes**

**Expected Time Complexity: No expected time complexity or time complexity limit.**
",['4\n3\n1 2 3\n5\n2 8 6 3 1\n4\n3 5 4 2\n5\n1000000000 1000000000 1000000000 1000000000 1000000000\n'],['NO\nYES\nNO\nNO\n'],"```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <algorithm>

int main() {
    // Optimize C++ standard streams for competitive programming
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int t;
    std::cin >> t; // Read the number of test cases
    while (t--) {
        int n;
        std::cin >> n; // Read the length of the sequence
        std::vector<long long> a(n);
        for (int i = 0; i < n; ++i) {
            std::cin >> a[i]; // Read the sequence elements
        }

        // Sort the sequence in non-decreasing order.
        // This is crucial for the greedy strategy: to maximize Sum(Red) for a small count,
        // pick the largest elements; to minimize Sum(Blue) for a large count, pick the smallest elements.
        // If a solution exists, there must be one where the red elements are the k largest
        // and blue elements are the m smallest (from the sorted list) for some k < m.
        std::sort(a.begin(), a.end());

        // We are looking for a partition into Red (R) and Blue (B) sets
        // such that Sum(R) > Sum(B) and Count(R) < Count(B).
        // Let Count(R) = k and Count(B) = m. We need k < m.
        // We check the most promising candidates: k largest elements for red,
        // and k+1 smallest elements for blue. This satisfies Count(R)=k < Count(B)=k+1.
        // For this to be a valid painting, the chosen elements must be distinct.
        // In the sorted array, the k largest are a[n-k]...a[n-1] and k+1 smallest are a[0]...a[k].
        // These sets of indices {n-k, ..., n-1} and {0, ..., k} are disjoint if k < n-k, i.e., 2k < n.
        // The smallest possible k is 1. The largest possible k satisfying 2k < n is floor((n-1)/2).
        // We iterate k from 1 up to floor((n-1)/2).
        // For a fixed k, if Sum(k largest) > Sum(k+1 smallest), we found a solution.
        // If this condition fails for m=k+1, it will also fail for any m' > k+1
        // because the sum of m' smallest elements will be greater than or equal to
        // the sum of k+1 smallest elements (since a_i >= 0).

        // Initialize sums for the first case: k=1 red, m=2 blue.
        // Red element: a[n-1]. Blue elements: a[0], a[1].
        long long current_sum_red = a[n - 1]; // Sum of 1 largest element
        long long current_sum_blue = a[0] + a[1]; // Sum of 2 smallest elements

        bool possible = false;
        // Iterate k from 1 up to floor((n-1)/2).
        // `k` in the loop represents the current Count(Red).
        // The corresponding Count(Blue) is k+1.
        // The loop condition `k * 2 < n` is equivalent to `k <= floor((n-1)/2)`.
        for (int k = 1; k * 2 < n; ++k) {
            // Check the condition for the current Count(Red) = k and Count(Blue) = k+1.
            if (current_sum_red > current_sum_blue) {
                possible = true;
                break; // Found a valid painting
            }

            // Update sums for the next iteration, where Count(Red) will be k+1
            // and Count(Blue) will be (k+1)+1 = k+2.
            // Add the next largest element for red: a[n - (k + 1)].
            // Add the next smallest element for blue: a[k + 1].
            // The loop variable `k` is the current Count(Red).
            // The next Count(Red) is `k+1`.
            // The index of the (k+1)-th largest element (0-indexed from end) is n - 1 - k.
            // The index of the (k+2)-th smallest element (0-indexed from start) is k + 1.
            // These updates prepare the sums for the check in the next iteration when the loop variable becomes k+1.
            current_sum_red += a[n - 1 - k];
            current_sum_blue += a[k + 1];
        }

        if (possible) {
            std::cout << ""YES\n"";
        } else {
            std::cout << ""NO\n"";
        }
    }

    return 0;
}

```"
