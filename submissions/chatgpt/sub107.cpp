#include <iostream>
#include <vector>
#include <set>
using namespace std;

// For each test case, we need to check if the given permutation can be generated by the described process.
// The process always allows to pick any of the leftmost contiguous block of unoccupied positions for the next number.
// So, at each step, the next number must be placed at one of the ends of the current contiguous block of unoccupied positions.

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        vector<int> p(n);
        for (int i = 0; i < n; ++i) {
            cin >> p[i];
        }

        // We use a set to keep track of the unoccupied positions (0-based).
        set<int> unoccupied;
        for (int i = 0; i < n; ++i) {
            unoccupied.insert(i);
        }

        // We also keep track of the current contiguous block [l, r] of unoccupied positions.
        // Initially, l = 0, r = n-1.
        int l = 0, r = n - 1;
        bool possible = true;

        // For each number from 1 to n, in the order of p[0]..p[n-1]:
        for (int i = 0; i < n; ++i) {
            int pos = p[i] - 1; // 0-based index

            // The only valid positions to place the next number are the leftmost or rightmost unoccupied positions.
            // If pos is not at l or r, then it's not possible.
            if (pos != l && pos != r) {
                possible = false;
                break;
            }

            // Remove pos from unoccupied positions.
            unoccupied.erase(pos);

            // Update l and r to the new leftmost and rightmost unoccupied positions.
            if (!unoccupied.empty()) {
                l = *unoccupied.begin();
                r = *unoccupied.rbegin();
            }
        }

        cout << (possible ? "Yes" : "No") << '\n';
    }
    return 0;
}