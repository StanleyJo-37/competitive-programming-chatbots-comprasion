#include <iostream>
#include <vector>
#include <cmath> // For std::abs
#include <algorithm> // For std::min, std::max

// Define a struct for coordinates to improve readability
struct Point {
    long long x, y;
};

// Function to calculate Manhattan distance between two points
long long manhattan_distance(Point p1, Point p2) {
    return std::abs(p1.x - p2.x) + std::abs(p1.y - p2.y);
}

int main() {
    // Optimize C++ standard streams for faster input/output.
    // This is a common practice in competitive programming.
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    // Declare variables for node generation parameters
    long long x0, y0, ax, ay, bx, by;
    // Read node generation parameters from input
    std::cin >> x0 >> y0 >> ax >> ay >> bx >> by;

    // Declare variables for Aroma's starting position and available time
    long long xs, ys, t;
    // Read Aroma's starting position and time from input
    std::cin >> xs >> ys >> t;

    // Vector to store generated data nodes.
    // Each node is a Point struct.
    nodes.push_back({x0, y0});

    // Define a practical upper bound for coordinates.
    // Coordinates can grow very large. We only care about nodes that are
    // potentially reachable within time 't'. The maximum coordinate value
    // we might need to consider is roughly xs + t or ys + t.
    // Since xs, ys, t can be up to 10^16, this sum can be 2 * 10^16.
    // To be safe and account for intermediate calculations, a limit like 4 * 10^16
    // is chosen. This also helps prevent long long overflow during generation
    // if ax or ay are large.
    const long long COORD_LIMIT = 4e16; // A sufficiently large value, e.g., 4 * 10^16

    // Generate data nodes until their coordinates exceed the practical limit.
    // The coordinates are generated by the recurrence relation:
    // x_i = a_x * x_{i-1} + b_x
    // y_i = a_y * y_{i-1} + b_y
    while (true) {
        // Get the last generated node's coordinates
        long long cur_x = nodes.back().x;
        long long cur_y = nodes.back().y;

        // Check for potential overflow or if the next node will be too far.
        // If cur_x is already large enough that a_x * cur_x + b_x would exceed COORD_LIMIT,
        // or if a_x * cur_x itself would overflow long long, then we stop.
        // The condition `cur_x > (COORD_LIMIT - bx) / ax` ensures that `ax * cur_x + bx`
        // will not exceed `COORD_LIMIT` (and also implicitly handles overflow for `ax * cur_x`
        // if `COORD_LIMIT` is chosen close to `LLONG_MAX`).
        // Since `ax, ay >= 2` and `bx, by >= 0`, coordinates are always increasing.
        if (cur_x > (COORD_LIMIT - bx) / ax || cur_y > (COORD_LIMIT - by) / ay) {
            break; // Next node would be too large or overflow
        }

        // Calculate coordinates for the next node
        long long next_x = ax * cur_x + bx;
        long long next_y = ay * cur_y + by;

        // Add the new node to the vector
        nodes.push_back({next_x, next_y});
    }

    // Initialize maximum collected nodes to 0
    int max_collected_nodes = 0;

    // Iterate over all possible starting nodes (left_idx) for a contiguous range
    for (int left_idx = 0; left_idx < nodes.size(); ++left_idx) {
        // Iterate over all possible ending nodes (right_idx) for the contiguous range
        // The right_idx must be greater than or equal to left_idx
        for (int right_idx = left_idx; right_idx < nodes.size(); ++right_idx) {
            // Calculate the number of nodes in the current range [left_idx, right_idx]
            int current_nodes_count = right_idx - left_idx + 1;

            // Calculate the time cost for two possible paths to collect nodes in this range:
            // Path 1: Start at (xs, ys), go to nodes[left_idx], then traverse to nodes[right_idx].
            // Total time = dist(start, nodes[left_idx]) + dist(nodes[left_idx], nodes[right_idx])
            long long cost1 = manhattan_distance({xs, ys}, nodes[left_idx]) +
                              manhattan_distance(nodes[left_idx], nodes[right_idx]);

            // Path 2: Start at (xs, ys), go to nodes[right_idx], then traverse to nodes[left_idx].
            // Total time = dist(start, nodes[right_idx]) + dist(nodes[right_idx], nodes[left_idx])
            long long cost2 = manhattan_distance({xs, ys}, nodes[right_idx]) +
                              manhattan_distance(nodes[right_idx], nodes[left_idx]);

            // The minimum time to collect all nodes in the range [left_idx, right_idx]
            // is the minimum of these two paths. This is because coordinates are
            // monotonically increasing, so traversing from one end of the range to the other
            // covers all intermediate nodes optimally.
            long long min_cost = std::min(cost1, cost2);

            // If the minimum cost is within the available time 't', update the maximum collected nodes
            // We must also ensure that min_cost does not exceed 't' and is non-negative.
            // Since distances are non-negative, min_cost will be non-negative.
            if (min_cost <= t) {
                max_collected_nodes = std::max(max_collected_nodes, current_nodes_count);
            }
        }
    }

    // Print the maximum number of data nodes Aroma can collect
    std::cout << max_collected_nodes << std::endl;

    return 0;
}