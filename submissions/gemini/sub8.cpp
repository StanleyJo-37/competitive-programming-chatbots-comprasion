#include <iostream> // Required for standard input/output operations, though not directly used in the function itself.

// The function to calculate the number of unique odd terms in the sequence up to the n-th term.
long long count_odd_pentaFib(int n) {
    // The sequence is defined as:
    // f(0) = 0
    // f(1) = 1
    // f(2) = 1
    // f(3) = 2
    // f(4) = 4
    // f(k) = f(k-1) + f(k-2) + f(k-3) + f(k-4) + f(k-5) for k >= 5

    // The problem asks for the count of *unique* odd terms.
    // It explicitly states: "The values 1 (one) is the only that is duplicated in the sequence and should be counted only once."
    // This implies that all other odd terms generated by the sequence (i.e., f(k) for k > 2) are unique.
    // This is a reasonable assumption for a fast-growing sequence.

    // We need to determine the parity (odd/even) of f(k) for k from 0 to n.
    // The parity of f(k) is (f(k-1)%2 + f(k-2)%2 + f(k-3)%2 + f(k-4)%2 + f(k-5)%2) % 2.
    // Let's list the parities (0 for Even, 1 for Odd):
    // f(0) = 0 (P=0)
    // f(1) = 1 (P=1)
    // f(2) = 1 (P=1)
    // f(3) = 2 (P=0)
    // f(4) = 4 (P=0)

    // Calculate subsequent parities:
    // P(5) = (P(4)+P(3)+P(2)+P(1)+P(0)) % 2 = (0+0+1+1+0) % 2 = 0
    // P(6) = (P(5)+P(4)+P(3)+P(2)+P(1)) % 2 = (0+0+0+1+1) % 2 = 0
    // P(7) = (P(6)+P(5)+P(4)+P(3)+P(2)) % 2 = (0+0+0+0+1) % 2 = 1 (Odd)
    // P(8) = (P(7)+P(6)+P(5)+P(4)+P(3)) % 2 = (1+0+0+0+0) % 2 = 1 (Odd)
    // P(9) = (P(8)+P(7)+P(6)+P(5)+P(4)) % 2 = (1+1+0+0+0) % 2 = 0
    // P(10) = (P(9)+P(8)+P(7)+P(6)+P(5)) % 2 = (0+1+1+0+0) % 2 = 0

    // The full parity sequence is:
    // Index: 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 ...
    // Parity: 0  1  1  0  0  0  0  1  1  0  0  0  0  1  1  0  ...

    // We observe a repeating pattern in the parities. The state of the recurrence is determined by the last 5 parities.
    // The state (P(k-5), P(k-4), P(k-3), P(k-2), P(k-1)) at k=4 is (0,1,1,0,0).
    // The state at k=10 is (P(6),P(7),P(8),P(9),P(10)) = (0,1,1,0,0).
    // Since the state repeats, the parity sequence becomes periodic starting from P(4).
    // The periodic block is (P(4), P(5), P(6), P(7), P(8), P(9)) = (0, 0, 0, 1, 1, 0).
    // This block has a length of 6 and contains two odd terms (1s).

    // The problem states 'n' will be a positive integer, so n >= 1.

    // Handle small values of n where the periodic pattern hasn't fully established or is not relevant.
    // For n from 1 to 6, the only odd term encountered is f(1)=1 (and f(2)=1).
    // According to the rule, '1' is counted only once.
    // f(0)=0, f(1)=1, f(2)=1, f(3)=2, f(4)=4, f(5)=8, f(6)=16.
    // In all these cases, the set of unique odd terms is {1}, so the count is 1.
    if (n < 7) {
        return 1;
    }

    // For n >= 7, we start with 1 for the value '1' (from f(1) or f(2)).
    long long total_unique_odd_count = 1;

    // Now, we count additional unique odd terms from f(7) up to f(n).
    // Based on the parity sequence, f(k) is odd for k >= 7 if k % 6 == 1 or k % 6 == 2.
    // (e.g., f(7) is odd because 7 % 6 = 1; f(8) is odd because 8 % 6 = 2;
    // f(13) is odd because 13 % 6 = 1; f(14) is odd because 14 % 6 = 2).

    // Calculate the number of terms from index 7 up to n, inclusive.
    long long num_terms_in_range_7_to_n = n - 7 + 1;

    // Each full cycle of 6 terms (e.g., indices 7-12, 13-18, etc.) contains exactly 2 odd terms.
    long long num_full_cycles = num_terms_in_range_7_to_n / 6;
    total_unique_odd_count += num_full_cycles * 2;

    // Account for any remaining terms in the partial cycle at the end.
    long long remaining_terms_in_cycle = num_terms_in_range_7_to_n % 6;

    // If there are remaining terms, check their parities:
    // The first term in the periodic block (corresponding to index 7, 13, 19, ...) is odd.
    if (remaining_terms_in_cycle >= 1) {
        total_unique_odd_count++;
    }
    // The second term in the periodic block (corresponding to index 8, 14, 20, ...) is odd.
    if (remaining_terms_in_cycle >= 2) {
        total_unique_odd_count++;
    }
    // The remaining terms (3, 4, 5, 0) in the cycle are even.

    return total_unique_odd_count;
}