#include <iostream> // Required for input/output operations (cin, cout)
#include <vector>   // Required for using std::vector to store names and s strings
#include <string>   // Required for using std::string for names and s strings

// Function to generate a unique name based on an integer index.
// Names are constructed using two English letters: the first is uppercase, the second is lowercase.
// The sequence of names generated is "Aa", "Ab", ..., "Az", "Ba", "Bb", ..., "Bz", "Ca", ...
// This scheme allows for 26 * 26 = 676 distinct names, which is more than sufficient for n <= 50.
std::string generate_name(int idx) {
    // The first character is an uppercase letter. It cycles through 'A' to 'Z' based on
    // how many full sets of 26 lowercase letters have been used (idx / 26).
    char first_char = 'A' + (idx / 26);
    // The second character is a lowercase letter. It cycles through 'a' to 'z' based on
    // the remainder when idx is divided by 26 (idx % 26).
    char second_char = 'a' + (idx % 26);
    // Construct the name string. std::string(1, char) creates a string containing a single character.
    return std::string(1, first_char) + std::string(1, second_char);
}

int main() {
    // Optimize C++ standard streams for competitive programming.
    // std::ios_base::sync_with_stdio(false) unties C++ streams from the C standard I/O library,
    // which can significantly speed up input/output operations.
    // std::cin.tie(NULL) prevents std::cout from flushing its buffer before std::cin reads input.
    // This further optimizes I/O by removing unnecessary synchronization.
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n, k; // n: total number of soldiers, k: size of a group
    std::cin >> n >> k; // Read the number of soldiers (n) and group size (k) from standard input.

    // A vector to store the effectiveness strings (s_1, s_2, ..., s_{n-k+1}).
    // There are (n - k + 1) such strings, each being "YES" or "NO".
    std::vector<std::string> s(n - k + 1);
    for (int i = 0; i < n - k + 1; ++i) {
        std::cin >> s[i]; // Read each effectiveness string into the vector.
    }

    // A vector to store the assigned names for the n soldiers.
    // Soldier indices will be 0 to n-1.
    std::vector<std::string> ans(n);
    // This counter keeps track of the next available unique name index.
    // It is incremented every time a new, distinct name is required.
    int fresh_name_idx = 0;

    // Iterate through each soldier from index 0 to n-1 to assign their names.
    for (int j = 0; j < n; ++j) {
        // The first k-1 soldiers (indices 0 to k-2) are initially assigned distinct names.
        // These names form the base for subsequent decisions. They are not directly
        // determined by an 's' string in terms of creating a duplicate within their initial segment.
        if (j < k - 1) {
            ans[j] = generate_name(fresh_name_idx++);
        } else {
            // For soldiers from index k-1 to n-1, their names are determined by the 's' strings.
            // The soldier at index 'j' is the last soldier in a group of 'k' consecutive soldiers.
            // This group starts at index `current_s_idx` and ends at index `j`.
            // The relationship is `j = current_s_idx + k - 1`, so `current_s_idx = j - (k - 1)`.
            // `s[current_s_idx]` describes the effectiveness of this group.
            int current_s_idx = j - (k - 1);

            // If the string `s[current_s_idx]` is "YES", it means the group of soldiers
            // from `current_s_idx` to `j` must have distinct names.
            // To ensure this, we assign `ans[j]` a completely new, unique name.
            // This new name (generated using `fresh_name_idx++`) is guaranteed to be distinct
            // from all names previously generated by `generate_name`, thus ensuring it's distinct
            // from `ans[current_s_idx], ..., ans[j-1]`.
            if (s[current_s_idx] == "YES") {
                ans[j] = generate_name(fresh_name_idx++);
            } else {
                // If the string `s[current_s_idx]` is "NO", it means the group of soldiers
                // from `current_s_idx` to `j` must NOT have distinct names (i.e., contain duplicates).
                // The simplest way to achieve this is to make `ans[j]` (the last soldier in the group)
                // have the same name as `ans[current_s_idx]` (the first soldier in the group).
                // This immediately creates a duplicate within the current window, satisfying the "NO" condition.
                ans[j] = ans[current_s_idx];
            }
        }
    }

    // Print the assigned names for all n soldiers, space-separated.
    for (int i = 0; i < n; ++i) {
        std::cout << ans[i] << (i == n - 1 ? "" : " "); // Print a space after each name except the last one.
    }
    std::cout << std::endl; // Print a newline character at the end of the output.

    return 0; // Indicate successful program execution.
}